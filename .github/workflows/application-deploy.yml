# .github/workflows/application-deploy.yml

name: "CI - Step 3 - Application Build and Deploy to ECR"
on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch (dev/staging/main)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging  
          - main
      tag:
        description: 'Git tag to deploy (for main branch only)'
        required: false
        type: string
      action:
        description: "Action to perform"
        required: true
        default: build-and-push
        type: choice
        options:
          - build-and-push
          - update-digest-only
          - force-rebuild
      auto_merge:
        description: "Auto-merge the GitOps PR"
        required: false
        default: true
        type: boolean
      force_cosign:
        description: "Force cosign operations even if no changes detected"
        required: false
        default: false
        type: boolean

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: it-works-on-my-machine
    permissions:
      contents: read
      id-token: write  # Required for OIDC
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch == 'main' && inputs.tag != '' && inputs.tag || inputs.target_branch }}
      
      ##### Currently Staging and Main use the same definitions as Dev
      # because the environment setup is handled in terraform and
      # i did not want to create multiple environments
      - name: Set environment variables
        run: |
          case "${{ github.event.inputs.target_branch }}" in
            dev|staging|main)
              echo "AWS_REGION=${{ vars.AWS_REGION_TF_DEV }}" >> $GITHUB_ENV
              echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_DEV }}" >> $GITHUB_ENV
              echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_DEV }}" >> $GITHUB_ENV
              echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_DEV }}" >> $GITHUB_ENV
              echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_DEV }}" >> $GITHUB_ENV
              ;;
            # staging)
            #   echo "AWS_REGION=${{ vars.AWS_REGION_TF_STAGING }}" >> $GITHUB_ENV
            #   echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_STAGING }}" >> $GITHUB_ENV
            #   echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_STAGING }}" >> $GITHUB_ENV
            #   echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_STAGING }}" >> $GITHUB_ENV
            #   echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_STAGING }}" >> $GITHUB_ENV
            #   ;;
            # main)
            #   echo "AWS_REGION=${{ vars.AWS_REGION_TF_PROD }}" >> $GITHUB_ENV
            #   echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_PROD }}" >> $GITHUB_ENV
            #   echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_PROD }}" >> $GITHUB_ENV
            #   echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_PROD }}" >> $GITHUB_ENV
            #   echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_PROD }}" >> $GITHUB_ENV
            #   ;;
          esac

      - name: Determine build strategy
        id: build-strategy
        run: |
          if [ "${{ github.event.inputs.action }}" == "force-rebuild" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "should_compare_digest=false" >> $GITHUB_OUTPUT
            echo "strategy=force" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Force rebuild - will build and push regardless"
          elif [ "${{ github.event.inputs.action }}" == "update-digest-only" ]; then
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "should_compare_digest=true" >> $GITHUB_OUTPUT
            echo "strategy=digest-only" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Update digest only - skipping build entirely"
          elif [ "${{ github.event.inputs.action }}" == "build-and-push" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "should_compare_digest=true" >> $GITHUB_OUTPUT
            echo "strategy=smart" >> $GITHUB_OUTPUT
            echo "ðŸ§  Smart build - will build, compare, and conditionally push"
          else
            echo "ðŸ§  Smart build - will do nothing"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        id: meta
        run: |
          SHA_SHORT=$(echo $GITHUB_SHA | cut -c1-7)
          TAG="${{ github.run_id }}-${SHA_SHORT}"
          IMAGE_BASE="${{ env.ECR_REPOSITORY_FRONTEND }}"
          IMAGE_URI="${IMAGE_BASE}:${TAG}"
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "DEBUG: image_uri=$IMAGE_URI"

          #echo "image_base=$IMAGE_BASE" >> $GITHUB_OUTPUT
          #echo "sha_short=$SHA_SHORT" >> $GITHUB_OUTPUT
      
      # Calculate content hash
      - name: Get content hash
        id: content-hash
        run: |
          CONTENT_HASH=$(find . -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          CONTENT_TAG="content-$CONTENT_HASH"
          echo "content_hash=$CONTENT_HASH" >> $GITHUB_OUTPUT
          echo "content_tag=$CONTENT_TAG" >> $GITHUB_OUTPUT
          echo "ðŸ“ Content hash: $CONTENT_HASH"
          echo "ðŸ“ Content tag: $CONTENT_TAG"

      # Get content hash from latest ECR image
      - name: Check if content exists in ECR
        if: ${{ steps.build-strategy.outputs.should_compare_digest == 'true' }}
        id: ecr-check
        run: |
          CONTENT_TAG="${{ steps.content-hash.outputs.content_tag }}"
         
          # Look for specific content tag instead of "latest"
          CONTENT_IMAGE=$(aws ecr describe-images \
            --repository-name $(basename ${{ env.ECR_REPOSITORY_FRONTEND }}) \
            --region ${{ env.AWS_REGION }} \
            --output json | jq '.imageDetails[] | select(.imageTags != null and (.imageTags[] | contains("'$CONTENT_TAG'"))) | . // {}' 2>/dev/null || echo "{}")
       
          echo "DEBUG: CONTENT_IMAGE=$CONTENT_IMAGE"
          if [ "$CONTENT_IMAGE" == "{}" ] && [ "${{ github.event.inputs.action }}" == "update-digest-only" ]; then
            echo "âŒ ERROR: 'update-digest-only' mode requires existing images in ECR"
            exit 1
          fi
         
          EXISTING_DIGEST=$(echo "$CONTENT_IMAGE" | jq -r '.imageDigest // ""')
          echo "existing_digest=$EXISTING_DIGEST" >> $GITHUB_OUTPUT
          echo "DEBUG: existing_digest=$EXISTING_DIGEST"
          # Check if content tag was found (handle both null and {})
          if [ "$CONTENT_IMAGE" != "{}" ] && [ "$CONTENT_IMAGE" != "null" ] && [ "$EXISTING_DIGEST" != "" ]; then
            echo "content_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Content tag found: $CONTENT_TAG"
            echo "We will NOT be pushing it to the ecr"
          else
            echo "content_exists=false" >> $GITHUB_OUTPUT
            echo "ðŸ†• Content tag not found: $CONTENT_TAG"
            echo "We will be pushing it to the ecr"
          fi

      - name: Compare content and decide to push
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        id: push-decision
        run: |
          if [ "${{ steps.build-strategy.outputs.strategy }}" == "force" ]; then
            echo "should_push=true" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Force push requested"
          elif [ "${{ steps.ecr-check.outputs.content_exists }}" == "false" ]; then
            echo "should_push=true" >> $GITHUB_OUTPUT
            echo "ðŸ†• Content not in ECR - pushing new content"
          else
            echo "should_push=false" >> $GITHUB_OUTPUT
            echo "âœ… Content unchanged - already exists in ECR, skipping push"
          fi

      ##### Required for both pulling from and pushing to private repositories
      - name: Login to Docker Hub
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
      #####

      # Build with content hash
      - name: Build Docker image
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          docker build -t ${{ steps.meta.outputs.image_uri }} .
          echo "âœ… Image built"

      # - name: Debug build variables  
      #   run: |
      #     cat > debug-vars.txt << EOF
      #     #GITHUB_SHA: ${{ github.sha }}
      #     #GITHUB_RUN_ID: ${{ github.run_id }}
      #     #TAG: ${{ steps.meta.outputs.tag }}
      #     IMAGE_URI: ${{ steps.meta.outputs.image_uri }}
      #     #IMAGE_BASE: ${{ env.ECR_REPOSITORY_FRONTEND }}
      #     EOF
      #     ls -la debug-vars.txt

      # - name: Upload debug artifact
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: debug-vars-${{ github.run_id }}
      #     path: it-works-on-my-machine/debug-vars.txt

      # - name: Debug content tag
      #   if: ${{ steps.push-decision.outputs.should_push == 'true' }}
      #   run: |
      #     echo "Content tag: '${{ steps.content-hash.outputs.content_tag }}'"
      #     echo "Full content tag: '${{ env.ECR_REPOSITORY_FRONTEND }}:${{ steps.content-hash.outputs.content_tag }}'"
          
      # - name: Push Docker image to ECR (with debug)
      #   if: ${{ steps.push-decision.outputs.should_push == 'true' }}
      #   run: |
      #     echo "Attempting to push: ${{ steps.meta.outputs.image_uri }}"
      #     set -e
      #     docker push ${{ steps.meta.outputs.image_uri }} 2>&1 || {
      #       echo "Push failed with exit code $?"
      #       echo "Checking docker login status..."
      #       docker system info | grep -i registry || echo "No registry info found"
      #       exit 1
      #     }

      - name: Push Docker image to ECR
        if: ${{ steps.push-decision.outputs.should_push == 'true' }}
        run: |
          echo "ðŸš€ Pushing image to ECR..."
          docker push ${{ steps.meta.outputs.image_uri }}
          echo "âœ… Image pushed successfully"

      - name: Capture final image digest
        id: final-digest
        run: |
          if [ "${{ steps.push-decision.outputs.should_push }}" == "true" ]; then
            # Get digest from newly pushed image
            NEW_DIGEST=$(aws ecr describe-images \
              --repository-name $(basename ${{ env.ECR_REPOSITORY_FRONTEND }}) \
              --region ${{ env.AWS_REGION }} \
              --image-ids imageTag=${{ steps.meta.outputs.tag }} \
              --query 'imageDetails[0].imageDigest' \
              --output text)
            echo "digest_only=$NEW_DIGEST" >> $GITHUB_OUTPUT
            echo "âœ… New image digest: $NEW_DIGEST"
          else
            # Use the existing latest digest (covers both digest-only and no-push scenarios)
            echo "digest_only=${{ steps.ecr-check.outputs.existing_digest }}" >> $GITHUB_OUTPUT
            echo "â™»ï¸ Using existing digest: ${{ steps.ecr-check.outputs.existing_digest }}"
          fi

      - name: Tag image with additional tags
        id: additional-tags
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          echo "ðŸ·ï¸ Checking and adding additional tags..."
          CHANGES_MADE=false

          # Function to check and add tag if missing
          check_and_add_tag() {
            local tag_name="$1"
            local tag_full="$2"
            
            echo "ðŸ” Checking $tag_name"
            TAG_EXISTS=$(aws ecr describe-images \
              --repository-name $(basename ${{ env.ECR_REPOSITORY_FRONTEND }}) \
              --region ${{ env.AWS_REGION }} \
              --image-ids imageDigest=${{ steps.final-digest.outputs.digest_only }} \
              --output json | jq -r '.imageDetails[0].imageTags[]? // empty' | grep -x "$tag_name" | head -1)
            
            if [ -z "$TAG_EXISTS" ]; then
              echo "ðŸ“ Adding $tag_name..."
              docker tag ${{ steps.meta.outputs.image_uri }} "$tag_full"
              docker push "$tag_full"
              echo "âœ… Created tag: $tag_name"
              CHANGES_MADE=true
            else
              echo "âœ… Tag already exists: $tag_name"
            fi
          }
          
          # Content tag (only if we pushed new content)
          if [ "${{ steps.push-decision.outputs.should_push }}" == "true" ]; then
            CONTENT_TAG="${{ steps.content-hash.outputs.content_tag }}"
            CONTENT_TAG_FULL="${{ env.ECR_REPOSITORY_FRONTEND }}:$CONTENT_TAG"
            check_and_add_tag "$CONTENT_TAG" "$CONTENT_TAG_FULL"
          fi
          
          # Digest tag (always for builds)
          DIGEST_TAG="sha256-$(echo ${{ steps.final-digest.outputs.digest_only }} | sed 's/sha256://')"
          DIGEST_TAG_FULL="${{ env.ECR_REPOSITORY_FRONTEND }}:$DIGEST_TAG"
          check_and_add_tag "$DIGEST_TAG" "$DIGEST_TAG_FULL"
          
          echo "changes_made=$CHANGES_MADE" >> $GITHUB_OUTPUT
          
          if [ "$CHANGES_MADE" = "true" ]; then
            echo "ðŸ”„ Changes made - new tags were added"
          else
            echo "âœ… No changes needed - all tags already exist"
          fi
          

      - name: Install Syft for SBOM generation
        if: ${{ steps.additional-tags.outputs.changes_made == 'true' || github.event.inputs.force_cosign == 'true' }}
        run: |
          echo "Installing Syft for SBOM generation..."
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          syft --version

      - name: Generate Software Bill of Materials
        if: ${{ steps.additional-tags.outputs.changes_made == 'true' || github.event.inputs.force_cosign == 'true' }}
        run: |
          echo "Generating Software Bill of Materials (SBOM)..."
          
          syft ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }} \
            -o spdx-json=sbom.spdx.json \
            -o cyclonedx-json=sbom.cyclonedx.json \
            -o table=sbom.txt
          
          echo "SBOM files created:"
          ls -la sbom.*
          echo "SBOM Summary:"
          head -10 sbom.txt

      - name: Upload SBOM artifacts
        if: ${{ steps.additional-tags.outputs.changes_made == 'true' || github.event.inputs.force_cosign == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-reports-${{ github.sha }}
          path: |
            it-works-on-my-machine/sbom.*
      
      - name: Generate build provenance
        if: ${{ steps.additional-tags.outputs.changes_made == 'true' || github.event.inputs.force_cosign == 'true' }}
        run: |
          echo "Generating build provenance..."
          
          cat > provenance.json << EOF
          {
            "builder": {
              "id": "https://github.com/actions/runner"
            },
            "buildType": "https://github.com/actions/workflow",
            "invocation": {
              "configSource": {
                "uri": "https://github.com/${{ github.repository }}",
                "digest": {
                  "sha1": "${{ github.sha }}"
                },
                "entryPoint": ".github/workflows/frontend-deploy.yml"
              },
              "parameters": {
                "branch": "${{ github.ref_name }}",
                "commit": "${{ github.sha }}",
                "workflow": "${{ github.workflow }}",
                "environment": "${{ github.event.inputs.target_branch }}",
                "runId": "${{ github.run_id }}"
              }
            },
            "metadata": {
              "buildInvocationId": "${{ github.run_id }}",
              "buildStartedOn": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
              "completeness": {
                "parameters": true,
                "environment": true,
                "materials": true
              }
            },
            "materials": [
              {
                "uri": "https://github.com/${{ github.repository }}",
                "digest": {
                  "sha1": "${{ github.sha }}"
                }
              }
            ]
          }
          EOF
          
          echo "Build provenance generated"
          cat provenance.json

      - name: Upload provenance
        if: ${{ steps.additional-tags.outputs.changes_made == 'true' || github.event.inputs.force_cosign == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: provenance-${{ github.sha }}
          path: it-works-on-my-machine/provenance.json

      - name: Install Cosign
        if: ${{ steps.additional-tags.outputs.changes_made == 'true' || github.event.inputs.force_cosign == 'true' }}
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.6.0'

      - name: Sign container image and attach attestations
        if: ${{ steps.additional-tags.outputs.changes_made == 'true' || github.event.inputs.force_cosign == 'true' }}
        run: |
          echo "ðŸ” Checking signature for digest: ${{ steps.final-digest.outputs.digest_only }}"
          
          # Try to verify signature exists
          if cosign verify \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }} 2>/dev/null; then
            echo "âœ… Signature already exists"
          else
            echo "ðŸ”‘ No signature found - signing now..."
            cosign sign --yes \
              --attachment-tag-prefix="SIGNATURE-" \
              ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }}
            echo "âœ… Image signed successfully"
          fi
          
          echo "ðŸ“Ž Attaching SBOM attestation..."
          cosign attest --yes \
            --predicate sbom.spdx.json \
            --attachment-tag-prefix="SBOM-" \
            --type spdx \
            ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }}
          echo "âœ… SBOM attestation attached"

          echo "ðŸ“Ž Attaching provenance attestation..."
          cosign attest --yes \
            --predicate provenance.json \
            --attachment-tag-prefix="PROVENANCE-" \
            --type slsaprovenance \
            ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }}
          echo "âœ… Provenance attestation attached"

      - name: Check if digest changed in GitOps
        id: check-gitops-changes
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
          ENVIRONMENT: ${{ github.event.inputs.target_branch }}
          TARGET_DIGEST: ${{ steps.final-digest.outputs.digest_only }}
        run: |
          rm -rf gitops-repo
          git clone https://x-access-token:${GH_TOKEN}@github.com/${GITOPS_REPO}.git gitops-repo
          cd gitops-repo
          
          # Checkout the target branch
          echo "Checking out target branch: ${ENVIRONMENT}"
          git checkout "${ENVIRONMENT}"
          
          # Check if digest file exists and get current digest
          DIGEST_FILE="manifests/frontend/digest-values.yaml"
          if [ -f "$DIGEST_FILE" ]; then
            GITOPS_DIGEST=$(grep 'digest:' "$DIGEST_FILE" | sed 's/.*digest: "\(.*\)"/\1/' || echo "none")
          else
            GITOPS_DIGEST="none"
            echo "ðŸ“ $DIGEST_FILE doesn't exist yet, will create it"
          fi
          
          if [ "$GITOPS_DIGEST" == "$TARGET_DIGEST" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "âœ… GitOps digest unchanged: gitops: $GITOPS_DIGEST vs $TARGET_DIGEST"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "ðŸ”„ GitOps digest will change: gitops_digest: $GITOPS_DIGEST â†’ target_digest: $TARGET_DIGEST"
          fi

      - name: Update GitOps repository
        if: ${{ steps.check-gitops-changes.outputs.changed == 'true' }}
        id: create-pr
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
          ENVIRONMENT: ${{ github.event.inputs.target_branch }}
          TARGET_DIGEST: ${{ steps.final-digest.outputs.digest_only }}
        run: |
          cd gitops-repo
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          BRANCH_NAME="frontend-update-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Create branch from target branch
          git checkout -b "$BRANCH_NAME"
          
          # Update or create digest file
          DIGEST_FILE="manifests/frontend/digest-values.yaml"
          mkdir -p "$(dirname "$DIGEST_FILE")"

          if [ -f "$DIGEST_FILE" ]; then
            # Update existing file
            sed -i "s|digest: \"sha256:.*\"|digest: \"${TARGET_DIGEST}\"|g" "$DIGEST_FILE"
          else
            # Create new file
            echo "## Frontend digest values" > "$DIGEST_FILE"
            echo "# managed by the application repo workflow (build-and-push action or update-digest-only)" >> "$DIGEST_FILE"
            echo "" >> "$DIGEST_FILE"
            echo "image:" >> "$DIGEST_FILE"
            echo "  digest: \"${TARGET_DIGEST}\"" >> "$DIGEST_FILE"
          fi

          git add "$DIGEST_FILE"
          git commit -m "Update frontend digest for ${ENVIRONMENT}: ${TARGET_DIGEST}"
          git push origin "$BRANCH_NAME"
          
          # Create PR targeting the correct branch
          PR_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${GITOPS_REPO}/pulls" \
            -d "{\"title\":\"Frontend: Update ${ENVIRONMENT} digest\",\"head\":\"${BRANCH_NAME}\",\"base\":\"${ENVIRONMENT}\",\"body\":\"Automated digest update for ${ENVIRONMENT} environment\"}")
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          if [ "$PR_NUMBER" != "null" ] && [ -n "$PR_NUMBER" ]; then
            echo "âœ… Created PR #${PR_NUMBER} targeting ${ENVIRONMENT} branch"
          else
            echo "âŒ Failed to create PR. Response: $PR_RESPONSE"
            exit 1
          fi
      
      - name: Auto-merge GitOps PR
        if: ${{ steps.check-gitops-changes.outputs.changed == 'true' && github.event.inputs.auto_merge == 'true' && github.event.inputs.target_branch != 'main' }}
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
        run: |
          PR_NUMBER="${{ steps.create-pr.outputs.pr_number }}"
          
          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
            echo "ðŸ”€ Triggering auto-merge for PR #${PR_NUMBER}..."
            
            curl -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${GITOPS_REPO}/dispatches" \
              -d "{\"event_type\":\"auto-merge-pr\",\"client_payload\":{\"pr_number\":${PR_NUMBER}}}"
            
            echo "âœ… Auto-merge workflow triggered for PR #${PR_NUMBER}"
          else
            echo "âŒ No PR found to auto-merge"
          fi
      
      - name: Build Summary
        run: |
          echo "## ðŸš€ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.target_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy:** ${{ steps.build-strategy.outputs.strategy }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Action:** ${{ github.event.inputs.action }}" >> $GITHUB_STEP_SUMMARY
          
          # ECR Digest Prior to the changes
          # no condition, if there are no digest the job fails anyway
          echo "- **ECR Digest Prior to the changes:** ${{ steps.ecr-check.outputs.existing_digest }}" >> $GITHUB_STEP_SUMMARY
          
          # If there were changes (meaning push = true)-> print the new digest which is the final digest
          if [ "${{ steps.push-decision.outputs.should_push }}" == "true" ]; then
            echo "- **ECR Digest after the changes:** ${{ steps.final-digest.outputs.digest_only }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- **Content Tag:** ${{ steps.content-hash.outputs.content_tag }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.build-strategy.outputs.should_build }}" == "true" ]; then
            echo "- **Built Image:** ${{ steps.meta.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
            #echo "- **Local content-hash:** ${{ steps.content-hash.outputs.content_hash }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Pushed to ECR:** ${{ steps.push-decision.outputs.should_push }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "- **GitOps Changed:** ${{ steps.check-gitops-changes.outputs.changed }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check-gitops-changes.outputs.changed }}" == "true" ]; then
            echo "- **PR Created:** #${{ steps.create-pr.outputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Auto-merge:** ${{ github.event.inputs.auto_merge }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Result:** No changes needed - everything up to date âœ…" >> $GITHUB_STEP_SUMMARY
          fi
          