# .github/workflows/base-image-management.yml

name: "Base Image Management - CI- Step 0"

on:
  # push:
  #   branches: [ main, develop ]
  #   paths:
  #     - 'it-works-on-my-machine/**'
  # pull_request:
  #   branches: [ main, develop ]
  #   paths:
  #     - 'it-works-on-my-machine/**'
  workflow_dispatch:
    inputs:
      base_image_with_digest:
        description: 'Base image with multi-arch manifest digest'
        required: false
        default: 'node:18-alpine@sha256:8d6421d663b4c28fd3ebc498332f249011d118945588d0a35cb9bc4b8ca09d9e'
        type: string
      base_image_manifest:
        description: 'SHA256 of base image manifest to pin'
        required: false
        default: 'sha256:929b04d7c782f04f615cf785488fed452b6569f87c73ff666ad553a7554f0006'
        # this is a manifest ID (a specific OS/Arch on top of the specific node version/ specific distro & version)
        # https://hub.docker.com/layers/library/node/18-alpine/images/sha256:929b04d7c782f04f615cf785488fed452b6569f87c73ff666ad553a7554f0006
        # Image Details: linux/amd64, alpine v3.21.3, node v18.20.8, npm v10.8.2
        type: string
      private_image_name:
        description: 'Private registry image name'
        required: false
        default: 'node-18-alpine-current'
        type: string
      target_version:
        description: 'Target version to use/create (e.g., 2025-01-15)'
        required: true
        default: '2025-09-25'
        type: string
      skip_stage_0:
        description: 'Skip Stage 0 (Base Image Management)'
        required: false
        default: false
        type: boolean
env:
  WORKFLOW_TIMEOUT: 15

jobs:
  stage0-base-image-management:
    runs-on: ubuntu-latest
    if: ${{ inputs.skip_stage_0 != true }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      ############################## Stage 0: Base Image Management & Supply Chain Security
      ############### Input Parsing and Validation
      ##### Parse base image inputs for deterministic builds
      ##### Extracts base image name and multi-arch manifest digest from input parameters
      ##### Ensures reproducible builds by pinning to specific image versions
      - name: Parse base image inputs
        id: parse_inputs
        run: |
          echo "üîç Parsing base image inputs..."
          BASE_IMAGE_NAME=$(echo "${{ inputs.base_image_with_digest }}" | cut -d'@' -f1)
          BASE_IMAGE_MULTIARCH_DIGEST=$(echo "${{ inputs.base_image_with_digest }}" | cut -d'@' -f2)
          echo "base_image_name=${BASE_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "base_image_multiarch_digest=${BASE_IMAGE_MULTIARCH_DIGEST}" >> $GITHUB_OUTPUT
          echo "‚úÖ Base image inputs parsed"
      #####

      ############### Provenance Label Schema Definition
      ##### Define static labels for build provenance and traceability
      ##### Creates metadata labels that track source image, manifest digests, and build context
      ##### Enables supply chain auditing and container forensics
      - name: Define label schema
        id: define_labels
        run: |
          echo "üè∑Ô∏è Defining label schema..."
          STATIC_LABELS=(
            "source.image:${{ steps.parse_inputs.outputs.base_image_name }}"
            "source.multiarch_manifest:${{ steps.parse_inputs.outputs.base_image_multiarch_digest }}"
            "source.linux_amd64_manifest:${{ inputs.base_image_manifest }}"
            "build.source:github-actions"
            "build.workflow:${{ github.workflow }}"
          )
          STATIC_LABELS_STRING=$(printf '%s|' "${STATIC_LABELS[@]}")
          echo "static_labels=${STATIC_LABELS_STRING%|}" >> $GITHUB_OUTPUT
          echo "‚úÖ Label schema defined"
      #####

      ############### Manifest Verification for Supply Chain Security
      ##### Extract and verify linux/amd64 specific manifest digest
      ##### Ensures the multi-arch image contains the expected architecture-specific manifest
      ##### Prevents supply chain attacks through manifest substitution
      - name: Extract and verify linux/amd64 manifest
        id: extract_manifest
        run: |
          echo "üîç Extracting and verifying linux/amd64 manifest..."
          ACTUAL_MANIFEST=$(docker buildx imagetools inspect ${{ inputs.base_image_with_digest }} --raw | jq -r '
            .manifests[] | select(.platform.architecture == "amd64" and .platform.os == "linux") | .digest
          ')
          if [[ "$ACTUAL_MANIFEST" != "${{ inputs.base_image_manifest }}" ]]; then
            echo "‚ùå Manifest verification failed!"
            exit 1
          fi
          echo "‚úÖ Manifest verification passed"
          echo "manifest_verified=true" >> $GITHUB_OUTPUT
      #####

      ############### Docker Hub Authentication
      ##### Authenticate with Docker Hub for private registry access
      ##### Required for both pulling from and pushing to private repositories
      - name: Login to Docker Hub
        run: |
          echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
      #####

      ############### Private Registry Cache Check
      ##### Check if image already exists in private registry with matching labels
      ##### Implements intelligent caching to avoid unnecessary rebuilds and pushes
      ##### Compares provenance labels to determine if image needs updating
      - name: Check private registry first
        id: check_private
        run: |
          echo "üîç Checking if image already exists in private registry..."
          IFS='|' read -ra STATIC_LABELS <<< "${{ steps.define_labels.outputs.static_labels }}"
          NEEDS_PUSH=true
          set +e
          #docker manifest inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} > /dev/null 2>&1
          docker manifest inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ inputs.target_version }} > /dev/null 2>&1
          MANIFEST_EXISTS=$?
          set -e
          
          if [ $MANIFEST_EXISTS -eq 0 ]; then
            echo "üîç Image found in private registry, checking labels..."
            #docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
            #docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} > /dev/null 2>&1            LABELS_MATCH=true
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ inputs.target_version }} > /dev/null 2>&1
            for label_pair in "${STATIC_LABELS[@]}"; do
              label_key=$(echo $label_pair | cut -d':' -f1)
              expected_value=$(echo $label_pair | cut -d':' -f2-)
              set +e
              #actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} --format="{{index .Config.Labels \"$label_key\"}}" 2>/dev/null)
              #actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} | jq -r ".[0].Config.Labels[\"$label_key\"] // \"\"")
              actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ inputs.target_version }} | jq -r ".[0].Config.Labels[\"$label_key\"] // \"\"")
              INSPECT_RESULT=$?
              echo "Expected: $expected_value"
              echo "Actual: $actual_value"
              set -e
              if [ $INSPECT_RESULT -ne 0 ] || [[ "$actual_value" != "$expected_value" ]]; then
                echo "‚ùå Label mismatch: $label_key"
                LABELS_MATCH=false
                break
              fi
            done
            if [ "$LABELS_MATCH" = true ]; then
              echo "‚úÖ All labels match - no push needed"
              NEEDS_PUSH=false
            fi
          else
            echo "‚ÑπÔ∏è Image not found in private registry - will need to push"
          fi
          echo "needs_push=$NEEDS_PUSH" >> $GITHUB_OUTPUT
      #####

      ############### Verified Image Pull and Private Registry Push
      ##### Pull base image with Content Trust verification from public Docker Hub
      ##### Tag and push to private registry with build metadata labels
      ##### Implements supply chain security by verifying public images before caching privately
      - name: Pull verified base image and push to private registry
        if: steps.check_private.outputs.needs_push == 'true' && steps.extract_manifest.outputs.manifest_verified == 'true'
        run: |
          echo "üê≥ Pulling verified base image and pushing to private registry..."
          
          # Enable Content Trust for pulling from public Docker Hub (verification only)
          export DOCKER_CONTENT_TRUST=1
          
          # Pull using the verified linux/amd64 manifest with trust verification
          echo "üì• Pulling base image with Content Trust verification..."
          docker pull ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }}
          
          # Disable Content Trust for private registry operations
          unset DOCKER_CONTENT_TRUST
          
          # Tag for private registry
          echo "üè∑Ô∏è Tagging for private registry..."

          #docker tag ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }} \
          #   ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          docker tag ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }} \
            "${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ inputs.target_version }}""
          
          # Parse the static labels
          IFS='|' read -ra STATIC_LABELS <<< "${{ steps.define_labels.outputs.static_labels }}"
          
          # Create a temporary Dockerfile to add labels
          echo "üìã Adding build metadata via temporary Dockerfile..."

          # cat > /tmp/Dockerfile.labels << 'EOF'
          # FROM ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          # EOF
          cat > /tmp/Dockerfile.labels << EOF
          FROM ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ inputs.target_version }}
          EOF
          
          # Add static labels to Dockerfile
          for label_pair in "${STATIC_LABELS[@]}"; do
            label_key=$(echo $label_pair | cut -d':' -f1)
            label_value=$(echo $label_pair | cut -d':' -f2-)
            echo "LABEL \"$label_key\"=\"$label_value\"" >> /tmp/Dockerfile.labels
          done
          
          # Add dynamic labels to Dockerfile
          echo "LABEL \"build.timestamp\"=\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" >> /tmp/Dockerfile.labels
          echo "LABEL \"build.run_id\"=\"${{ github.run_id }}\"" >> /tmp/Dockerfile.labels
          
          # Build and push with labels (without Content Trust signing)

          # docker build -f /tmp/Dockerfile.labels -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} .
          # docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          docker build -f /tmp/Dockerfile.labels -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ inputs.target_version }} .
          docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ inputs.target_version }}

          # Clean up
          rm /tmp/Dockerfile.labels
          
          echo "‚úÖ Base image management completed with verified public image and private registry caching"
    #####
    ###############
  ##############################
    