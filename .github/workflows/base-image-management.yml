# .github/workflows/base-image-management.yml

name: "Base Image Management - CI- Step 0"

on:
  # push:
  #   branches: [ main, develop ]
  #   paths:
  #     - 'it-works-on-my-machine/**'
  # pull_request:
  #   branches: [ main, develop ]
  #   paths:
  #     - 'it-works-on-my-machine/**'
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch (dev/staging/main)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging  
          - main
      base_image_with_digest:
        description: 'Base image with multi-arch manifest digest'
        required: false
        default: 'node:18-alpine@sha256:8d6421d663b4c28fd3ebc498332f249011d118945588d0a35cb9bc4b8ca09d9e'
        type: string
      base_image_manifest:
        description: 'SHA256 of base image manifest to pin'
        required: false
        default: 'sha256:929b04d7c782f04f615cf785488fed452b6569f87c73ff666ad553a7554f0006'
        # this is a manifest ID (a specific OS/Arch on top of the specific node version/ specific distro & version)
        # https://hub.docker.com/layers/library/node/18-alpine/images/sha256:929b04d7c782f04f615cf785488fed452b6569f87c73ff666ad553a7554f0006
        # Image Details: linux/amd64, alpine v3.21.3, node v18.20.8, npm v10.8.2
        type: string
      private_image_name:
        description: 'Private registry image name'
        required: false
        default: 'node-18-alpine-current'
        type: string
      target_version:
        description: 'Target version to use/create (e.g., 2025-01-15 or "latest")'
        required: true
        default: 'latest'
        type: string
      skip_stage_0:
        description: 'Skip Stage 0 (Base Image Management)'
        required: false
        default: false
        type: boolean
env:
  WORKFLOW_TIMEOUT: 15

jobs:
  stage0-base-image-management:
    runs-on: ubuntu-latest
    if: ${{ inputs.skip_stage_0 != true }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch }}
      
      ############################## Stage 0: Base Image Management & Supply Chain Security
      ############### Input Parsing and Validation
      ##### Parse base image inputs for deterministic builds
      ##### Extracts base image name and multi-arch manifest digest from input parameters
      ##### Ensures reproducible builds by pinning to specific image versions
      - name: Parse base image inputs
        id: parse_inputs
        run: |
          echo "üîç Parsing base image inputs..."
          BASE_IMAGE_NAME=$(echo "${{ inputs.base_image_with_digest }}" | cut -d'@' -f1)
          BASE_IMAGE_MULTIARCH_DIGEST=$(echo "${{ inputs.base_image_with_digest }}" | cut -d'@' -f2)
          echo "base_image_name=${BASE_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "base_image_multiarch_digest=${BASE_IMAGE_MULTIARCH_DIGEST}" >> $GITHUB_OUTPUT
          echo "‚úÖ Base image inputs parsed"
      #####

      ############### Provenance Label Schema Definition
      ##### Define static labels for build provenance and traceability
      ##### Creates metadata labels that track source image, manifest digests, and build context
      ##### Enables supply chain auditing and container forensics
      - name: Define label schema
        id: define_labels
        run: |
          echo "üè∑Ô∏è Defining label schema..."
          STATIC_LABELS=(
            "source.image:${{ steps.parse_inputs.outputs.base_image_name }}"
            "source.multiarch_manifest:${{ steps.parse_inputs.outputs.base_image_multiarch_digest }}"
            "source.linux_amd64_manifest:${{ inputs.base_image_manifest }}"
            "build.source:github-actions"
            "build.workflow:${{ github.workflow }}"
          )
          STATIC_LABELS_STRING=$(printf '%s|' "${STATIC_LABELS[@]}")
          echo "static_labels=${STATIC_LABELS_STRING%|}" >> $GITHUB_OUTPUT
          echo "‚úÖ Label schema defined"
      #####

      ############### Manifest Verification for Supply Chain Security
      ##### Extract and verify linux/amd64 specific manifest digest
      ##### Ensures the multi-arch image contains the expected architecture-specific manifest
      ##### Prevents supply chain attacks through manifest substitution
      - name: Extract and verify linux/amd64 manifest
        id: extract_manifest
        run: |
          echo "üîç Extracting and verifying linux/amd64 manifest..."
          ACTUAL_MANIFEST=$(docker buildx imagetools inspect ${{ inputs.base_image_with_digest }} --raw | jq -r '
            .manifests[] | select(.platform.architecture == "amd64" and .platform.os == "linux") | .digest
          ')
          if [[ "$ACTUAL_MANIFEST" != "${{ inputs.base_image_manifest }}" ]]; then
            echo "‚ùå Manifest verification failed!"
            exit 1
          fi
          echo "‚úÖ Manifest verification passed"
          echo "manifest_verified=true" >> $GITHUB_OUTPUT
      #####

      ############### Docker Hub Authentication
      ##### Authenticate with Docker Hub for private registry access
      ##### Required for both pulling from and pushing to private repositories
      - name: Login to Docker Hub
        run: |
          echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
      #####

      ############### Target Version Resolution
      ##### Resolve target version - if "latest" is specified, find the most recent date tag
      ##### If latest image has no date tag, use today's date
      ##### This provides better UX while maintaining date-based versioning internally
      - name: Resolve target version
        id: resolve_version
        run: |
          if [ "${{ inputs.target_version }}" = "latest" ]; then
            echo "üîç Resolving 'latest' to actual date tag..."
            
            # Get all tags and find the most recent date tag
            LATEST_DATE_TAG=$(curl -s "https://registry-1.docker.io/v2/${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}/tags/list" \
              -H "Authorization: Bearer $(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:pull" | jq -r .token)" \
              | jq -r '.tags[]' | grep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' | sort -r | head -1 2>/dev/null || echo "")
            
            if [ -n "$LATEST_DATE_TAG" ]; then
              RESOLVED_VERSION="$LATEST_DATE_TAG"
              echo "‚úÖ Found latest date tag: $LATEST_DATE_TAG"
            else
              RESOLVED_VERSION=$(date -u +%Y-%m-%d)
              echo "‚ÑπÔ∏è No date tags found, using today's date: $RESOLVED_VERSION"
            fi
          else
            RESOLVED_VERSION="${{ inputs.target_version }}"
            echo "‚úÖ Using specified version: $RESOLVED_VERSION"
          fi
          
          echo "resolved_version=$RESOLVED_VERSION" >> $GITHUB_OUTPUT
          echo "üéØ Target version resolved to: $RESOLVED_VERSION"
      #####

      ############### Private Registry Cache Check
      ##### Check if image already exists in private registry with matching labels
      ##### Implements intelligent caching to avoid unnecessary rebuilds and pushes
      ##### Compares provenance labels to determine if image needs updating
      - name: Check private registry first
        id: check_private
        run: |
          echo "üîç Checking if image already exists in private registry..."
          echo "resolved_version is:  ${{ steps.resolve_version.outputs.resolved_version }}"
          IFS='|' read -ra STATIC_LABELS <<< "${{ steps.define_labels.outputs.static_labels }}"
          NEEDS_PUSH=true
          set +e
          #docker manifest inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} > /dev/null 2>&1
          docker manifest inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }} > /dev/null 2>&1
          MANIFEST_EXISTS=$?
          set -e
          
          if [ $MANIFEST_EXISTS -eq 0 ]; then
            echo "üîç Image found in private registry, checking labels..."
            #docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
            #docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} > /dev/null 2>&1
            LABELS_MATCH=true
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }} > /dev/null 2>&1
            for label_pair in "${STATIC_LABELS[@]}"; do
              label_key=$(echo $label_pair | cut -d':' -f1)
              expected_value=$(echo $label_pair | cut -d':' -f2-)
              set +e
              #actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} --format="{{index .Config.Labels \"$label_key\"}}" 2>/dev/null)
              #actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} | jq -r ".[0].Config.Labels[\"$label_key\"] // \"\"")
              actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }} | jq -r ".[0].Config.Labels[\"$label_key\"] // \"\"")
              INSPECT_RESULT=$?
              echo "Expected: $expected_value"
              echo "Actual: $actual_value"
              set -e
              if [ $INSPECT_RESULT -ne 0 ] || [[ "$actual_value" != "$expected_value" ]]; then
                echo "‚ùå Label mismatch: $label_key"
                LABELS_MATCH=false
                break
              fi
            done
            if [ "$LABELS_MATCH" = true ]; then
              echo "‚úÖ All labels match - no push needed"
              NEEDS_PUSH=false
            fi
          else
            echo "‚ÑπÔ∏è Image not found in private registry - will need to push"
          fi
          echo "needs_push=$NEEDS_PUSH" >> $GITHUB_OUTPUT
      #####

      ############### Verified Image Pull and Private Registry Push
      ##### Pull base image with Content Trust verification from public Docker Hub
      ##### Tag and push to private registry with build metadata labels
      ##### Implements supply chain security by verifying public images before caching privately
      - name: Pull verified base image and push to private registry
        if: steps.check_private.outputs.needs_push == 'true' && steps.extract_manifest.outputs.manifest_verified == 'true'
        run: |
          echo "üê≥ Pulling verified base image and pushing to private registry..."
          
          # Enable Content Trust for pulling from public Docker Hub (verification only)
          export DOCKER_CONTENT_TRUST=1
          
          # Pull using the verified linux/amd64 manifest with trust verification
          echo "üì• Pulling base image with Content Trust verification..."
          docker pull ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }}
          
          # Disable Content Trust for private registry operations
          unset DOCKER_CONTENT_TRUST
          
          # Tag for private registry
          echo "üè∑Ô∏è Tagging for private registry..."

          #docker tag ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }} \
          #   ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          docker tag ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }} \
            "${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}"
          
          # Parse the static labels
          IFS='|' read -ra STATIC_LABELS <<< "${{ steps.define_labels.outputs.static_labels }}"
          
          # Create a temporary Dockerfile to add labels
          echo "üìã Adding build metadata via temporary Dockerfile..."

          # cat > /tmp/Dockerfile.labels << 'EOF'
          # FROM ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          # EOF
          cat > /tmp/Dockerfile.labels << 'EOF'
          FROM ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}
          EOF
          
          # Add static labels to Dockerfile
          for label_pair in "${STATIC_LABELS[@]}"; do
            label_key=$(echo $label_pair | cut -d':' -f1)
            label_value=$(echo $label_pair | cut -d':' -f2-)
            echo "LABEL \"$label_key\"=\"$label_value\"" >> /tmp/Dockerfile.labels
          done
          
          # Add dynamic labels to Dockerfile
          echo "LABEL \"build.timestamp\"=\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" >> /tmp/Dockerfile.labels
          echo "LABEL \"build.run_id\"=\"${{ github.run_id }}\"" >> /tmp/Dockerfile.labels
          
          # Build and push with labels (without Content Trust signing)

          # docker build -f /tmp/Dockerfile.labels -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} .
          # docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          docker build -f /tmp/Dockerfile.labels -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }} .
          docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}

          # Clean up
          rm /tmp/Dockerfile.labels
          
          echo "‚úÖ Base image management completed with verified public image and private registry caching"
      #####
      ###############
      ##############################
  stage1-dockerfile-check:
    runs-on: ubuntu-latest
    needs: stage0-base-image-management
    if: ${{ inputs.skip_stage_0 != true }}
    steps:
      - name: Checkout target branch
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch }}
      
      - name: Resolve target version (duplicate from stage0)
        id: resolve_version
        run: |
          if [ "${{ inputs.target_version }}" = "latest" ]; then
            echo "üîç Resolving 'latest' to actual date tag..."
            
            # Get all tags and find the most recent date tag
            LATEST_DATE_TAG=$(curl -s "https://registry-1.docker.io/v2/${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}/tags/list" \
              -H "Authorization: Bearer $(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:pull" | jq -r .token)" \
              | jq -r '.tags[]' | grep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' | sort -r | head -1 2>/dev/null || echo "")
            
            if [ -n "$LATEST_DATE_TAG" ]; then
              RESOLVED_VERSION="$LATEST_DATE_TAG"
              echo "‚úÖ Found latest date tag: $LATEST_DATE_TAG"
            else
              RESOLVED_VERSION=$(date -u +%Y-%m-%d)
              echo "‚ÑπÔ∏è No date tags found, using today's date: $RESOLVED_VERSION"
            fi
          else
            RESOLVED_VERSION="${{ inputs.target_version }}"
            echo "‚úÖ Using specified version: $RESOLVED_VERSION"
          fi
          
          echo "resolved_version=$RESOLVED_VERSION" >> $GITHUB_OUTPUT
          echo "üéØ Target version resolved to: $RESOLVED_VERSION"
      
      ############################## Stage 1: Dockerfile Validation & Update Check
      ############### Dockerfile Analysis
      ##### Check all FROM statements in Dockerfile to see if they match expected private registry
      ##### Determines if Dockerfile needs updating to use the resolved base image version
      - name: Check Dockerfile FROM statements
        id: dockerfile_check
        run: |
          echo "üîç Checking Dockerfile FROM statements..."
          
          DOCKERFILE_PATH="it-works-on-my-machine/Dockerfile"
          EXPECTED_FROM="FROM ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}"
          
          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "‚ùå ERROR: Dockerfile not found at $DOCKERFILE_PATH"
            exit 1
          fi
          
          # Get all FROM statements
          FROM_STATEMENTS=$(grep "^FROM" "$DOCKERFILE_PATH" || echo "")
          
          if [ -z "$FROM_STATEMENTS" ]; then
            echo "‚ùå ERROR: No FROM statements found in Dockerfile"
            exit 1
          fi
          
          echo "üìã Found FROM statements:"
          echo "$FROM_STATEMENTS"
          echo ""
          echo "üìã Expected FROM statement:"
          echo "$EXPECTED_FROM"
          echo ""
          
          # Check if any FROM statement doesn't match expected
          CHANGES_REQUIRED=false
          while IFS= read -r from_line; do
            if [[ "$from_line" != "$EXPECTED_FROM" ]]; then
              echo "‚ùå FROM mismatch found: $from_line"
              CHANGES_REQUIRED=true
            else
              echo "‚úÖ FROM statement matches: $from_line"
            fi
          done <<< "$FROM_STATEMENTS"
          
          if [ "$CHANGES_REQUIRED" = true ]; then
            echo "üîÑ Dockerfile changes required"
            echo "changes_required=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Dockerfile is up to date"
            echo "changes_required=false" >> $GITHUB_OUTPUT
          fi
      #####
      
      ############### Summary
      - name: Stage 1 Summary
        if: always()
        run: |
          echo "üìä Stage 1: Dockerfile Check Summary"
          echo "================================="
          echo "Target Branch: ${{ inputs.target_branch }}"
          echo "Resolved Version: ${{ steps.resolve_version.outputs.resolved_version }}"
          echo "Changes Required: ${{ steps.dockerfile_check.outputs.changes_required }}"
          echo "================================="
      #####
    