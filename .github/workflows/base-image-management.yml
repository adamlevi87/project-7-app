# .github/workflows/base-image-management.yml

name: "CI - Step 0 - Base Image Management"

on:
  # push:
  #   branches: [ main, develop ]
  #   paths:
  #     - 'it-works-on-my-machine/**'
  # pull_request:
  #   branches: [ main, develop ]
  #   paths:
  #     - 'it-works-on-my-machine/**'
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch (dev/staging/main)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging  
          - main
      tag:
        description: 'Git tag to deploy (for main branch only)'
        required: false
        type: string
      base_image_with_digest:
        description: 'Base image with multi-arch manifest digest'
        required: false
        default: 'node:18-alpine@sha256:8d6421d663b4c28fd3ebc498332f249011d118945588d0a35cb9bc4b8ca09d9e'
        type: string
      base_image_manifest:
        description: 'SHA256 of base image manifest to pin'
        required: false
        default: 'sha256:929b04d7c782f04f615cf785488fed452b6569f87c73ff666ad553a7554f0006'
        # this is a manifest ID (a specific OS/Arch on top of the specific node version/ specific distro & version)
        # https://hub.docker.com/layers/library/node/18-alpine/images/sha256:929b04d7c782f04f615cf785488fed452b6569f87c73ff666ad553a7554f0006
        # Image Details: linux/amd64, alpine v3.21.3, node v18.20.8, npm v10.8.2
        type: string
      private_image_name:
        description: 'Private registry image name'
        required: false
        default: 'node-18-alpine-current'
        type: string
      target_version:
        description: 'Target version to use/create (e.g., 2025-01-15 or "latest")'
        required: true
        default: 'latest'
        type: string
      skip_stage_0:
        description: 'Skip Stage 0 (Base Image Management)'
        required: false
        default: true
        type: boolean
      skip_stage_1:
        description: 'Skip Stage 1 (handling dockerfile)'
        required: false
        default: false
        type: boolean
      skip_stage_2:
        description: 'Skip Stage 2 (Trigger CI)'
        required: false
        default: false
        type: boolean
env:
  WORKFLOW_TIMEOUT: 15

jobs:
  stage0-base-image-management:
    runs-on: ubuntu-latest
    if: ${{ inputs.skip_stage_0 != true }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch == 'main' && inputs.tag != '' && inputs.tag || inputs.target_branch }}
      
      ############################## Stage 0: Base Image Management & Supply Chain Security
      ############### Input Parsing and Validation
      ##### Parse base image inputs for deterministic builds
      ##### Extracts base image name and multi-arch manifest digest from input parameters
      ##### Ensures reproducible builds by pinning to specific image versions
      - name: Parse base image inputs
        id: parse_inputs
        run: |
          echo "üîç Parsing base image inputs..."
          BASE_IMAGE_NAME=$(echo "${{ inputs.base_image_with_digest }}" | cut -d'@' -f1)
          BASE_IMAGE_MULTIARCH_DIGEST=$(echo "${{ inputs.base_image_with_digest }}" | cut -d'@' -f2)
          echo "base_image_name=${BASE_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "base_image_multiarch_digest=${BASE_IMAGE_MULTIARCH_DIGEST}" >> $GITHUB_OUTPUT
          echo "‚úÖ Base image inputs parsed"
      #####

      ############### Provenance Label Schema Definition
      ##### Define static labels for build provenance and traceability
      ##### Creates metadata labels that track source image, manifest digests, and build context
      ##### Enables supply chain auditing and container forensics
      - name: Define label schema
        id: define_labels
        run: |
          echo "üè∑Ô∏è Defining label schema..."
          STATIC_LABELS=(
            "source.image:${{ steps.parse_inputs.outputs.base_image_name }}"
            "source.multiarch_manifest:${{ steps.parse_inputs.outputs.base_image_multiarch_digest }}"
            "source.linux_amd64_manifest:${{ inputs.base_image_manifest }}"
            "build.source:github-actions"
            "build.workflow:${{ github.workflow }}"
          )
          STATIC_LABELS_STRING=$(printf '%s|' "${STATIC_LABELS[@]}")
          echo "static_labels=${STATIC_LABELS_STRING%|}" >> $GITHUB_OUTPUT
          echo "‚úÖ Label schema defined"
      #####

      ############### Manifest Verification for Supply Chain Security
      ##### Extract and verify linux/amd64 specific manifest digest
      ##### Ensures the multi-arch image contains the expected architecture-specific manifest
      ##### Prevents supply chain attacks through manifest substitution
      - name: Extract and verify linux/amd64 manifest
        id: extract_manifest
        run: |
          echo "üîç Extracting and verifying linux/amd64 manifest..."
          ACTUAL_MANIFEST=$(docker buildx imagetools inspect ${{ inputs.base_image_with_digest }} --raw | jq -r '
            .manifests[] | select(.platform.architecture == "amd64" and .platform.os == "linux") | .digest
          ')
          if [[ "$ACTUAL_MANIFEST" != "${{ inputs.base_image_manifest }}" ]]; then
            echo "‚ùå Manifest verification failed!"
            exit 1
          fi
          echo "‚úÖ Manifest verification passed"
          echo "manifest_verified=true" >> $GITHUB_OUTPUT
      #####

      ############### Docker Hub Authentication
      ##### Authenticate with Docker Hub for private registry access
      ##### Required for both pulling from and pushing to private repositories
      - name: Login to Docker Hub
        run: |
          echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
      #####

      ############### Target Version Resolution
      ##### Resolve target version - if "latest" is specified, find the most recent date tag
      ##### If latest image has no date tag, use today's date
      ##### This provides better UX while maintaining date-based versioning internally
      - name: Resolve target version
        id: resolve_version
        run: |
          if [ "${{ inputs.target_version }}" = "latest" ]; then
            echo "üîç Resolving 'latest' to actual date tag..."
            
            # Get all tags and find the most recent date tag
            LATEST_DATE_TAG=$(curl -s "https://registry-1.docker.io/v2/${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}/tags/list" \
              -H "Authorization: Bearer $(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:pull" | jq -r .token)" \
              | jq -r '.tags[]' | grep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' | sort -r | head -1 2>/dev/null || echo "")
            
            if [ -n "$LATEST_DATE_TAG" ]; then
              RESOLVED_VERSION="$LATEST_DATE_TAG"
              echo "‚úÖ Found latest date tag: $LATEST_DATE_TAG"
            else
              RESOLVED_VERSION=$(date -u +%Y-%m-%d)
              echo "‚ÑπÔ∏è No date tags found, using today's date: $RESOLVED_VERSION"
            fi
          else
            RESOLVED_VERSION="${{ inputs.target_version }}"
            echo "‚úÖ Using specified version: $RESOLVED_VERSION"
          fi
          
          echo "resolved_version=$RESOLVED_VERSION" >> $GITHUB_OUTPUT
          echo "üéØ Target version resolved to: $RESOLVED_VERSION"
      #####

      ############### Private Registry Cache Check
      ##### Check if image already exists in private registry with matching labels
      ##### Implements intelligent caching to avoid unnecessary rebuilds and pushes
      ##### Compares provenance labels to determine if image needs updating
      - name: Check private registry first
        id: check_private
        run: |
          echo "üîç Checking if image already exists in private registry..."
          echo "resolved_version is:  ${{ steps.resolve_version.outputs.resolved_version }}"
          IFS='|' read -ra STATIC_LABELS <<< "${{ steps.define_labels.outputs.static_labels }}"
          NEEDS_PUSH=true
          set +e
          #docker manifest inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} > /dev/null 2>&1
          docker manifest inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }} > /dev/null 2>&1
          MANIFEST_EXISTS=$?
          set -e
          
          if [ $MANIFEST_EXISTS -eq 0 ]; then
            echo "üîç Image found in private registry, checking labels..."
            #docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
            #docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} > /dev/null 2>&1
            LABELS_MATCH=true
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }} > /dev/null 2>&1
            for label_pair in "${STATIC_LABELS[@]}"; do
              label_key=$(echo $label_pair | cut -d':' -f1)
              expected_value=$(echo $label_pair | cut -d':' -f2-)
              set +e
              #actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} --format="{{index .Config.Labels \"$label_key\"}}" 2>/dev/null)
              #actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} | jq -r ".[0].Config.Labels[\"$label_key\"] // \"\"")
              actual_value=$(docker inspect ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }} | jq -r ".[0].Config.Labels[\"$label_key\"] // \"\"")
              INSPECT_RESULT=$?
              echo "Expected: $expected_value"
              echo "Actual: $actual_value"
              set -e
              if [ $INSPECT_RESULT -ne 0 ] || [[ "$actual_value" != "$expected_value" ]]; then
                echo "‚ùå Label mismatch: $label_key"
                LABELS_MATCH=false
                break
              fi
            done
            if [ "$LABELS_MATCH" = true ]; then
              echo "‚úÖ All labels match - no push needed"
              NEEDS_PUSH=false
            fi
          else
            echo "‚ÑπÔ∏è Image not found in private registry - will need to push"
          fi
          echo "needs_push=$NEEDS_PUSH" >> $GITHUB_OUTPUT
      #####

      ############### Verified Image Pull and Private Registry Push
      ##### Pull base image with Content Trust verification from public Docker Hub
      ##### Tag and push to private registry with build metadata labels
      ##### Implements supply chain security by verifying public images before caching privately
      - name: Pull verified base image and push to private registry
        if: steps.check_private.outputs.needs_push == 'true' && steps.extract_manifest.outputs.manifest_verified == 'true'
        run: |
          echo "üê≥ Pulling verified base image and pushing to private registry..."
          
          # Enable Content Trust for pulling from public Docker Hub (verification only)
          export DOCKER_CONTENT_TRUST=1
          
          # Pull using the verified linux/amd64 manifest with trust verification
          echo "üì• Pulling base image with Content Trust verification..."
          docker pull ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }}
          
          # Disable Content Trust for private registry operations
          unset DOCKER_CONTENT_TRUST
          
          # Tag for private registry
          echo "üè∑Ô∏è Tagging for private registry..."

          #docker tag ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }} \
          #   ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          docker tag ${{ steps.parse_inputs.outputs.base_image_name }}@${{ inputs.base_image_manifest }} \
            "${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}"
          
          # Parse the static labels
          IFS='|' read -ra STATIC_LABELS <<< "${{ steps.define_labels.outputs.static_labels }}"
          
          # Create a temporary Dockerfile to add labels
          echo "üìã Adding build metadata via temporary Dockerfile..."

          # cat > /tmp/Dockerfile.labels << 'EOF'
          # FROM ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          # EOF
          cat > /tmp/Dockerfile.labels << 'EOF'
          FROM ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}
          EOF
          
          # Add static labels to Dockerfile
          for label_pair in "${STATIC_LABELS[@]}"; do
            label_key=$(echo $label_pair | cut -d':' -f1)
            label_value=$(echo $label_pair | cut -d':' -f2-)
            echo "LABEL \"$label_key\"=\"$label_value\"" >> /tmp/Dockerfile.labels
          done
          
          # Add dynamic labels to Dockerfile
          echo "LABEL \"build.timestamp\"=\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" >> /tmp/Dockerfile.labels
          echo "LABEL \"build.run_id\"=\"${{ github.run_id }}\"" >> /tmp/Dockerfile.labels
          
          # Build and push with labels (without Content Trust signing)

          # docker build -f /tmp/Dockerfile.labels -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }} .
          # docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}
          docker build -f /tmp/Dockerfile.labels -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }} .
          docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}

          # Clean up
          rm /tmp/Dockerfile.labels
          
          echo "‚úÖ Base image management completed with verified public image and private registry caching"

      - name: Stage 0 Summary
        if: always()
        run: |
          echo "## üìä Stage 0: Base Image Management & Supply Chain Security" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Target Branch** | \`${{ inputs.target_branch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Base Image** | \`${{ steps.parse_inputs.outputs.base_image_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Multi-arch Digest** | \`${{ steps.parse_inputs.outputs.base_image_multiarch_digest }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Platform Manifest** | \`${{ inputs.base_image_manifest }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Private Registry** | \`${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Target Version** | \`${{ steps.resolve_version.outputs.resolved_version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Actions Taken" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.check_private.outputs.needs_push }}" == "true" ]; then
            echo "- ‚úÖ **Image pulled from public Docker Hub with Content Trust verification**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Build metadata labels applied**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Image pushed to private registry:** \`${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ÑπÔ∏è **No push needed** - Image already exists in private registry with matching labels" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
      #####
      ###############
      ##############################
  stage1-handling-dockerfile:
    runs-on: ubuntu-latest
    needs: stage0-base-image-management
    permissions:
      contents: write        # Required to create branches and commit
      pull-requests: write   # Required to create and merge PRs
      actions: read         # Standard read access
    if: ${{ inputs.skip_stage_1 != true && !failure() && !cancelled() }}
    outputs:
      changes_required: ${{ steps.dockerfile_check.outputs.changes_required }}
    steps:
      - name: Checkout target branch
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch }}
      
      - name: Resolve target version (duplicate from stage0)
        id: resolve_version
        run: |
          if [ "${{ inputs.target_version }}" = "latest" ]; then
            echo "üîç Resolving 'latest' to actual date tag..."
            
            # Get all tags and find the most recent date tag
            LATEST_DATE_TAG=$(curl -s "https://registry-1.docker.io/v2/${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}/tags/list" \
              -H "Authorization: Bearer $(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:pull" | jq -r .token)" \
              | jq -r '.tags[]' | grep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' | sort -r | head -1 2>/dev/null || echo "")
            
            if [ -n "$LATEST_DATE_TAG" ]; then
              RESOLVED_VERSION="$LATEST_DATE_TAG"
              echo "‚úÖ Found latest date tag: $LATEST_DATE_TAG"
            else
              RESOLVED_VERSION=$(date -u +%Y-%m-%d)
              echo "‚ÑπÔ∏è No date tags found, using today's date: $RESOLVED_VERSION"
            fi
          else
            RESOLVED_VERSION="${{ inputs.target_version }}"
            echo "‚úÖ Using specified version: $RESOLVED_VERSION"
          fi
          
          echo "resolved_version=$RESOLVED_VERSION" >> $GITHUB_OUTPUT
          echo "üéØ Target version resolved to: $RESOLVED_VERSION"
      
      ############################## Stage 1: Dockerfile Validation & Update Check
      ############### Dockerfile Analysis
      ##### Check all FROM statements in Dockerfile to see if they match expected private registry
      ##### Determines if Dockerfile needs updating to use the resolved base image version
      - name: Check Dockerfile FROM statements
        id: dockerfile_check
        run: |
          echo "üîç Checking Dockerfile FROM statements..."
          
          DOCKERFILE_PATH="it-works-on-my-machine/Dockerfile"
          EXPECTED_BASE_IMAGE="${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}"
          
          echo "üìù Updating all FROM statements to use: ${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}"

          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "‚ùå ERROR: Dockerfile not found at $DOCKERFILE_PATH"
            exit 1
          fi
          
          # Get all FROM statements
          FROM_STATEMENTS=$(grep "^FROM" "$DOCKERFILE_PATH" || echo "")
          
          if [ -z "$FROM_STATEMENTS" ]; then
            echo "‚ùå ERROR: No FROM statements found in Dockerfile"
            exit 1
          fi
          
          echo "üìã Found FROM statements:"
          echo "$FROM_STATEMENTS"
          echo ""
          echo "üìã Expected base image:"
          echo "$EXPECTED_BASE_IMAGE"
          echo ""
          
          # Check if any FROM statement doesn't match expected
          CHANGES_REQUIRED=false
          while IFS= read -r from_line; do
            # Extract just the image part (before any AS clause)
            IMAGE_PART=$(echo "$from_line" | awk '{print $2}')
            
            if [[ "$IMAGE_PART" != "$EXPECTED_BASE_IMAGE" ]]; then
              echo "‚ùå FROM mismatch found: $from_line (expected base: $EXPECTED_BASE_IMAGE)"
              CHANGES_REQUIRED=true
            else
              echo "‚úÖ FROM statement matches: $from_line"
            fi
          done <<< "$FROM_STATEMENTS"
          
          if [ "$CHANGES_REQUIRED" = true ]; then
            echo "üîÑ Dockerfile changes required"
            echo "changes_required=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Dockerfile is up to date"
            echo "changes_required=false" >> $GITHUB_OUTPUT
          fi
      #####
      
      ############### Create Branch and Update Dockerfile
      ##### Create a new branch from target branch and update Dockerfile FROM statements
      ##### Only runs when changes are required to avoid unnecessary operations
      - name: Create branch and update Dockerfile
        if: steps.dockerfile_check.outputs.changes_required == 'true'
        id: update_dockerfile
        run: |
          echo "üåø Creating branch and updating Dockerfile..."
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action - Base Image Update"
          
          # Create unique branch name
          BRANCH_NAME="base-image-update-${{ inputs.target_branch }}-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Create and switch to new branch
          git checkout -b "$BRANCH_NAME"
          
          # Update Dockerfile - replace all FROM statements
          DOCKERFILE_PATH="it-works-on-my-machine/Dockerfile"
          EXPECTED_BASE_IMAGE="${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}"
          
          echo "üìù Updating all FROM statements to: $EXPECTED_BASE_IMAGE"
          
          # Use sed to replace FROM statements while preserving AS clauses
          sed -i "s|${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:[^ ]*|$EXPECTED_BASE_IMAGE|g" "$DOCKERFILE_PATH"
          
          #echo "üìã Dockerfile content after sed:"
          #cat "$DOCKERFILE_PATH"

          # Verify changes
          echo "üìã Updated Dockerfile FROM statements:"
          grep "^FROM" "$DOCKERFILE_PATH"
          
          # Stage and commit changes
          git add "$DOCKERFILE_PATH"
          git commit -m "chore: update base image to ${{ steps.resolve_version.outputs.resolved_version }}

          - Updated by base-image-management workflow
          - Target branch: ${{ inputs.target_branch }}
          - Base image version: ${{ steps.resolve_version.outputs.resolved_version }}
          - Updated all FROM statements in $DOCKERFILE_PATH"
          
          # Push branch
          git push origin "$BRANCH_NAME"
          
          echo "‚úÖ Branch created and Dockerfile updated"
      #####

      ############### Create Pull Request
      ##### Create PR to merge Dockerfile changes back to target branch
      ##### Only runs when Dockerfile was actually updated
      - name: Create Pull Request
        if: steps.dockerfile_check.outputs.changes_required == 'true'
        id: create_pr
        run: |
          echo "üîÑ Creating Pull Request..."
          
          BRANCH_NAME="${{ steps.update_dockerfile.outputs.branch_name }}"
          PR_TITLE="Base Image: Update ${{ inputs.target_branch }} to ${{ steps.resolve_version.outputs.resolved_version }}"
          
          # Create PR body in a temp file to handle newlines properly
          cat > /tmp/pr_body.txt << 'EOF'
          Automated base image update for ${{ inputs.target_branch }} branch

          **Changes:**
          - Updated Dockerfile base image to `${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}`
          - All FROM statements updated to use private registry

          **Generated by:** base-image-management workflow
          **Target Branch:** ${{ inputs.target_branch }}
          **Base Image Version:** ${{ steps.resolve_version.outputs.resolved_version }}
          EOF

          # Create PR using jq to properly format JSON
          PR_RESPONSE=$(jq -n \
            --arg title "$PR_TITLE" \
            --arg head "$BRANCH_NAME" \
            --arg base "${{ inputs.target_branch }}" \
            --rawfile body /tmp/pr_body.txt \
            '{title: $title, head: $head, base: $base, body: $body}' | \
            curl -s -X POST \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d @-)
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          if [ "$PR_NUMBER" != "null" ] && [ -n "$PR_NUMBER" ]; then
            echo "‚úÖ Created PR #${PR_NUMBER}"
          else
            echo "‚ùå Failed to create PR. Response: $PR_RESPONSE"
            exit 1
          fi
      #####

      ############### Auto-merge Logic
      ##### Auto-merge PR for dev/staging, leave open for main/prod
      ##### Based on target branch to implement different approval workflows
      - name: Auto-merge PR
        if: steps.dockerfile_check.outputs.changes_required == 'true' && (inputs.target_branch == 'dev' || inputs.target_branch == 'staging')
        run: |
          echo "üîÄ Auto-merging PR for ${{ inputs.target_branch }} branch..."
          
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          
          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
            echo "‚è≥ Waiting for PR to be ready for merge..."
            sleep 10
            
            # Auto-merge using GitHub CLI
            gh pr merge $PR_NUMBER \
              --repo ${{ github.repository }} \
              --squash \
              --delete-branch \
              || {
                echo "‚ùå Failed to auto-merge PR #$PR_NUMBER"
                echo "PR will remain open for manual review"
              }
            
            echo "‚úÖ Auto-merged PR #${PR_NUMBER} for ${{ inputs.target_branch }}"
          else
            echo "‚ùå No PR found to auto-merge"
          fi
        env:
          GH_TOKEN: ${{ github.token }}
      
      ############### Manual Review Notice
      ##### Notify that manual review is required for production branches
      - name: Manual Review Notice
        if: steps.dockerfile_check.outputs.changes_required == 'true' && (inputs.target_branch == 'main')
        run: |
          echo "üìã Manual review required for ${{ inputs.target_branch }} branch"
          echo "PR #${{ steps.create_pr.outputs.pr_number }} created and awaiting review"
          echo "This is intentional for production safety"
      #####

      ############### Summary
      - name: Stage 1 Summary  
        if: always()
        run: |
          echo "## üìä Stage 1: Dockerfile Validation & Update" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Target Branch** | \`${{ inputs.target_branch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Expected Base Image** | \`${{ secrets.DOCKER_HUB_USERNAME }}/${{ inputs.private_image_name }}:${{ steps.resolve_version.outputs.resolved_version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Changes Required** | \`${{ steps.dockerfile_check.outputs.changes_required }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Actions Taken" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.dockerfile_check.outputs.changes_required }}" == "true" ]; then
            echo "- üîÑ **Dockerfile update needed**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Branch created:** \`${{ steps.update_dockerfile.outputs.branch_name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Pull Request created:** #${{ steps.create_pr.outputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ inputs.target_branch }}" == "dev" ] || [ "${{ inputs.target_branch }}" == "staging" ]; then
              echo "- ‚úÖ **PR auto-merged** (dev/staging)" >> $GITHUB_STEP_SUMMARY
            else
              echo "- ‚è≥ **Manual review required** (main/prod)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "- ‚úÖ **Dockerfile is up to date** - No changes needed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
      #####
  stage2-trigger-ci:
    runs-on: ubuntu-latest
    needs: stage1-handling-dockerfile
    if: ${{ inputs.skip_stage_2 != true && !failure() && !cancelled() && (inputs.skip_stage_1 == true || needs.stage1-handling-dockerfile.outputs.changes_required == 'false') }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Trigger and wait for Unified CI Pipeline
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üöÄ Triggering unified CI pipeline for ${{ inputs.target_branch }} branch..."
          
          gh workflow run unified-ci-pipeline.yml \
            --ref ${{ inputs.target_branch }} \
            -f target_branch=${{ inputs.target_branch }}
          
          echo "‚è≥ Waiting for unified CI workflow to complete..."
          
          # Wait a moment for the run to be created
          sleep 5
          
          # Get the most recent run ID for this workflow
          RUN_ID=$(gh run list --workflow=unified-ci-pipeline.yml --limit 1 --json databaseId --jq '.[0].databaseId')
          
          echo "üìä Watching run ID: $RUN_ID"
          
          # Wait for completion and check status
          gh run watch $RUN_ID --exit-status
          
          echo "‚úÖ Unified CI pipeline completed successfully for ${{ inputs.target_branch }}"
      
      - name: Stage 2 Summary
        if: always()
        run: |
          echo "## üìä Stage 2: CI Pipeline Trigger" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Target Branch** | \`${{ inputs.target_branch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Dockerfile Changes Required** | \`${{ needs.stage1-handling-dockerfile.outputs.changes_required }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Trigger Decision" >> $GITHUB_STEP_SUMMARY
          if [ "${{ inputs.target_branch }}" == "main" ] && [ "${{ needs.stage1-handling-dockerfile.outputs.changes_required }}" == "true" ]; then
            echo "- ‚è∏Ô∏è **CI not triggered** - Production PR requires manual merge" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ÑπÔ∏è CI will run automatically when PR is merged" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.stage1-handling-dockerfile.outputs.changes_required }}" == "true" ]; then
            echo "- ‚è∏Ô∏è **CI not triggered** - Dockerfile PR will trigger CI on merge" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚úÖ **Unified CI Pipeline triggered** - No Dockerfile changes, running CI now" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY