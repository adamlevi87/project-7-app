# .github/workflows/frontend-deploy.yml

name: Frontend - Build and Deploy to ECR
on:
  workflow_dispatch:
    inputs:
      env:
        description: "Environment to manage"
        required: true
        default: dev
        type: choice
        options:
          - dev
          - staging
          - prod
      action:
        description: "Action to perform"
        required: true
        default: build-and-push
        type: choice
        options:
          - build-and-push
          - update-digest-only
          - force-rebuild
      auto_merge:
        description: "Auto-merge the GitOps PR"
        required: false
        default: true
        type: boolean

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: it-works-on-my-machine
    permissions:
      contents: read
      id-token: write  # Required for OIDC
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # with:
        #   fetch-depth: 2  # Need previous commit for change detection
      
      - name: Set environment variables
        run: |
          case "${{ github.event.inputs.env }}" in
            dev)
              echo "AWS_REGION=${{ vars.AWS_REGION_TF_DEV }}" >> $GITHUB_ENV
              echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_DEV }}" >> $GITHUB_ENV
              echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_DEV }}" >> $GITHUB_ENV
              echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_DEV }}" >> $GITHUB_ENV
              echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_DEV }}" >> $GITHUB_ENV
              ;;
            staging)
              echo "AWS_REGION=${{ vars.AWS_REGION_TF_STAGING }}" >> $GITHUB_ENV
              echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_STAGING }}" >> $GITHUB_ENV
              echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_STAGING }}" >> $GITHUB_ENV
              echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_STAGING }}" >> $GITHUB_ENV
              echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_STAGING }}" >> $GITHUB_ENV
              ;;
            prod)
              echo "AWS_REGION=${{ vars.AWS_REGION_TF_PROD }}" >> $GITHUB_ENV
              echo "AWS_ROLE_TO_ASSUME=${{ secrets.AWS_ROLE_TO_ASSUME_TF_PROD }}" >> $GITHUB_ENV
              echo "ECR_REPOSITORY_FRONTEND=${{ secrets.ECR_REPOSITORY_FRONTEND_TF_PROD }}" >> $GITHUB_ENV
              echo "GH_TOKEN=${{ secrets.TOKEN_GITHUB_TF_PROD }}" >> $GITHUB_ENV
              echo "GITOPS_REPO=${{ vars.GITOPS_REPO_TF_PROD }}" >> $GITHUB_ENV
              ;;
          esac

      - name: Determine build strategy
        id: build-strategy
        run: |
          if [ "${{ github.event.inputs.action }}" == "force-rebuild" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "should_compare_digest=false" >> $GITHUB_OUTPUT
            echo "strategy=force" >> $GITHUB_OUTPUT
            echo "🔨 Force rebuild - will build and push regardless"
          elif [ "${{ github.event.inputs.action }}" == "update-digest-only" ]; then
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "should_compare_digest=true" >> $GITHUB_OUTPUT
            echo "strategy=digest-only" >> $GITHUB_OUTPUT
            echo "📦 Update digest only - skipping build entirely"
          elif [ "${{ github.event.inputs.action }}" == "build-and-push" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "should_compare_digest=true" >> $GITHUB_OUTPUT
            echo "strategy=smart" >> $GITHUB_OUTPUT
            echo "🧠 Smart build - will build, compare, and conditionally push"
          else
            echo "🧠 Smart build - will do nothing"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        id: meta
        run: |
          SHA_SHORT=$(echo $GITHUB_SHA | cut -c1-7)
          TAG="${{ github.run_id }}-${SHA_SHORT}"
          IMAGE_BASE="${{ env.ECR_REPOSITORY_FRONTEND }}"
          IMAGE_URI="${IMAGE_BASE}:${TAG}"
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "DEBUG: image_uri=$IMAGE_URI"

          #echo "image_base=$IMAGE_BASE" >> $GITHUB_OUTPUT
          #echo "sha_short=$SHA_SHORT" >> $GITHUB_OUTPUT
      
      # Calculate content hash
      - name: Get content hash
        id: content-hash
        run: |
          CONTENT_HASH=$(find . -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          CONTENT_TAG="content-$CONTENT_HASH"
          echo "content_hash=$CONTENT_HASH" >> $GITHUB_OUTPUT
          echo "content_tag=$CONTENT_TAG" >> $GITHUB_OUTPUT
          echo "📝 Content hash: $CONTENT_HASH"
          echo "📝 Content tag: $CONTENT_TAG"

      # Get content hash from latest ECR image
      - name: Check if content exists in ECR
        if: ${{ steps.build-strategy.outputs.should_compare_digest == 'true' }}
        id: ecr-check
        run: |
          CONTENT_TAG="${{ steps.content-hash.outputs.content_tag }}"
         
          # Look for specific content tag instead of "latest"
          CONTENT_IMAGE=$(aws ecr describe-images \
            --repository-name $(basename ${{ env.ECR_REPOSITORY_FRONTEND }}) \
            --region ${{ env.AWS_REGION }} \
            --output json | jq '.imageDetails[] | select(.imageTags != null and (.imageTags[] | contains("'$CONTENT_TAG'"))) | . // {}' 2>/dev/null || echo "{}")
       
          echo "DEBUG: CONTENT_IMAGE=$CONTENT_IMAGE"
          if [ "$CONTENT_IMAGE" == "{}" ] && [ "${{ github.event.inputs.action }}" == "update-digest-only" ]; then
            echo "❌ ERROR: 'update-digest-only' mode requires existing images in ECR"
            exit 1
          fi
         
          EXISTING_DIGEST=$(echo "$CONTENT_IMAGE" | jq -r '.imageDigest // ""')
          echo "existing_digest=$EXISTING_DIGEST" >> $GITHUB_OUTPUT
          echo "DEBUG: existing_digest=$EXISTING_DIGEST"
          # Check if content tag was found (handle both null and {})
          if [ "$CONTENT_IMAGE" != "{}" ] && [ "$CONTENT_IMAGE" != "null" ] && [ "$EXISTING_DIGEST" != "" ]; then
            echo "content_exists=true" >> $GITHUB_OUTPUT
            echo "✅ Content tag found: $CONTENT_TAG"
            echo "We will NOT be pushing it to the ecr"
          else
            echo "content_exists=false" >> $GITHUB_OUTPUT
            echo "🆕 Content tag not found: $CONTENT_TAG"
            echo "We will be pushing it to the ecr"
          fi

      - name: Compare content and decide to push
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        id: push-decision
        run: |
          if [ "${{ steps.build-strategy.outputs.strategy }}" == "force" ]; then
            echo "should_push=true" >> $GITHUB_OUTPUT
            echo "🔨 Force push requested"
          elif [ "${{ steps.ecr-check.outputs.content_exists }}" == "false" ]; then
            echo "should_push=true" >> $GITHUB_OUTPUT
            echo "🆕 Content not in ECR - pushing new content"
          else
            echo "should_push=false" >> $GITHUB_OUTPUT
            echo "✅ Content unchanged - already exists in ECR, skipping push"
          fi

      ##### Required for both pulling from and pushing to private repositories
      - name: Login to Docker Hub
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
      #####

      # Build with content hash
      - name: Build Docker image
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          docker build -t ${{ steps.meta.outputs.image_uri }} .
          echo "✅ Image built"

      - name: Debug build variables  
        run: |
          cat > debug-vars.txt << EOF
          #GITHUB_SHA: ${{ github.sha }}
          #GITHUB_RUN_ID: ${{ github.run_id }}
          #TAG: ${{ steps.meta.outputs.tag }}
          IMAGE_URI: ${{ steps.meta.outputs.image_uri }}
          #IMAGE_BASE: ${{ env.ECR_REPOSITORY_FRONTEND }}
          EOF
          ls -la debug-vars.txt

      - name: Upload debug artifact
        uses: actions/upload-artifact@v4
        with:
          name: debug-vars-${{ github.run_id }}
          path: it-works-on-my-machine/debug-vars.txt

      # - name: Debug content tag
      #   if: ${{ steps.push-decision.outputs.should_push == 'true' }}
      #   run: |
      #     echo "Content tag: '${{ steps.content-hash.outputs.content_tag }}'"
      #     echo "Full content tag: '${{ env.ECR_REPOSITORY_FRONTEND }}:${{ steps.content-hash.outputs.content_tag }}'"
          
      # - name: Push Docker image to ECR (with debug)
      #   if: ${{ steps.push-decision.outputs.should_push == 'true' }}
      #   run: |
      #     echo "Attempting to push: ${{ steps.meta.outputs.image_uri }}"
      #     set -e
      #     docker push ${{ steps.meta.outputs.image_uri }} 2>&1 || {
      #       echo "Push failed with exit code $?"
      #       echo "Checking docker login status..."
      #       docker system info | grep -i registry || echo "No registry info found"
      #       exit 1
      #     }

      - name: Push Docker image to ECR
        if: ${{ steps.push-decision.outputs.should_push == 'true' }}
        run: |
          echo "🚀 Pushing image to ECR..."
          docker push ${{ steps.meta.outputs.image_uri }}

          CONTENT_TAG_FULL="${{ env.ECR_REPOSITORY_FRONTEND }}:${{ steps.content-hash.outputs.content_tag }}"
          docker tag ${{ steps.meta.outputs.image_uri }} $CONTENT_TAG_FULL
          docker push $CONTENT_TAG_FULL
          
          echo "✅ Image pushed successfully"
          echo "✅ Content tag created: ${{ steps.content-hash.outputs.content_tag }}"

      - name: Capture final image digest
        id: final-digest
        run: |
          if [ "${{ steps.push-decision.outputs.should_push }}" == "true" ]; then
            # Get digest from newly pushed image
            NEW_DIGEST=$(aws ecr describe-images \
              --repository-name $(basename ${{ env.ECR_REPOSITORY_FRONTEND }}) \
              --region ${{ env.AWS_REGION }} \
              --image-ids imageTag=${{ steps.meta.outputs.tag }} \
              --query 'imageDetails[0].imageDigest' \
              --output text)
            echo "digest_only=$NEW_DIGEST" >> $GITHUB_OUTPUT
            echo "✅ New image digest: $NEW_DIGEST"
          else
            # Use the existing latest digest (covers both digest-only and no-push scenarios)
            echo "digest_only=${{ steps.ecr-check.outputs.existing_digest }}" >> $GITHUB_OUTPUT
            echo "♻️ Using existing digest: ${{ steps.ecr-check.outputs.existing_digest }}"
          fi

      # - name: Tag image with digest identifier
      #   if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
      #   run: |
      #     DIGEST_TAG="sha256-$(echo ${{ steps.final-digest.outputs.digest_only }} | sed 's/sha256://')"
      #     DIGEST_TAG_FULL="${{ env.ECR_REPOSITORY_FRONTEND }}:$DIGEST_TAG"
      #     docker tag ${{ steps.meta.outputs.image_uri }} $DIGEST_TAG_FULL
      #     docker push $DIGEST_TAG_FULL
      #     echo "✅ Image pushed successfully"
      #     echo "✅ Created digest-based tag: $DIGEST_TAG"

      - name: Install Syft for SBOM generation
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          echo "Installing Syft for SBOM generation..."
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          syft --version

      - name: Generate Software Bill of Materials
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          echo "Generating Software Bill of Materials (SBOM)..."
          
          syft ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }} \
            -o spdx-json=sbom.spdx.json \
            -o cyclonedx-json=sbom.cyclonedx.json \
            -o table=sbom.txt
          
          echo "SBOM files created:"
          ls -la sbom.*
          echo "SBOM Summary:"
          head -10 sbom.txt

      - name: Upload SBOM artifacts
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-reports-${{ github.sha }}
          path: |
            it-works-on-my-machine/sbom.*
      
      - name: Generate build provenance
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          echo "Generating build provenance..."
          
          cat > provenance.json << EOF
          {
            "builder": {
              "id": "https://github.com/actions/runner"
            },
            "buildType": "https://github.com/actions/workflow",
            "invocation": {
              "configSource": {
                "uri": "https://github.com/${{ github.repository }}",
                "digest": {
                  "sha1": "${{ github.sha }}"
                },
                "entryPoint": ".github/workflows/frontend-deploy.yml"
              },
              "parameters": {
                "branch": "${{ github.ref_name }}",
                "commit": "${{ github.sha }}",
                "workflow": "${{ github.workflow }}",
                "environment": "${{ github.event.inputs.env }}",
                "runId": "${{ github.run_id }}"
              }
            },
            "metadata": {
              "buildInvocationId": "${{ github.run_id }}",
              "buildStartedOn": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
              "completeness": {
                "parameters": true,
                "environment": true,
                "materials": true
              }
            },
            "materials": [
              {
                "uri": "https://github.com/${{ github.repository }}",
                "digest": {
                  "sha1": "${{ github.sha }}"
                }
              }
            ]
          }
          EOF
          
          echo "Build provenance generated"
          cat provenance.json

      - name: Upload provenance
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: provenance-${{ github.sha }}
          path: it-works-on-my-machine/provenance.json

      - name: Install Cosign
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.6.0'

      - name: Sign container image and attach attestations
        if: ${{ steps.build-strategy.outputs.should_build == 'true' }}
        run: |
          echo "🔍 Checking signature for digest: ${{ steps.final-digest.outputs.digest_only }}"
          
          # Try to verify signature exists
          if cosign verify \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }} 2>/dev/null; then
            echo "✅ Signature already exists"
          else
            echo "🔑 No signature found - signing now..."
            cosign sign --yes \
              --attachment-tag-prefix="SIGNATURE-" \
              ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }}
            echo "✅ Image signed successfully"
          fi
          
          echo "📎 Attaching SBOM attestation..."
          cosign attest --yes \
            --predicate sbom.spdx.json \
            --attachment-tag-prefix="SBOM-" \
            --type spdx \
            ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }}
          echo "✅ SBOM attestation attached"

          echo "📎 Attaching provenance attestation..."
          cosign attest --yes \
            --predicate provenance.json \
            --attachment-tag-prefix="PROVENANCE-" \
            --type slsaprovenance \
            ${{ env.ECR_REPOSITORY_FRONTEND }}@${{ steps.final-digest.outputs.digest_only }}
          echo "✅ Provenance attestation attached"

      - name: Check if digest changed in GitOps
        id: check-gitops-changes
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
          ENVIRONMENT: ${{ github.event.inputs.env }}
          # TARGET_DIGEST is the digest from this workflow
          # it will be the latest digest from the ECR, if a push was made or not
          # this needs to be compared to the digest in GitOps
          TARGET_DIGEST: ${{ steps.final-digest.outputs.digest_only }}
        run: |
          rm -rf gitops-repo
          git clone https://x-access-token:${GH_TOKEN}@github.com/${GITOPS_REPO}.git gitops-repo
          cd gitops-repo
          
          GITOPS_DIGEST=$(grep 'digest:' environments/${ENVIRONMENT}/manifests/frontend/digest-values.yaml | sed 's/.*digest: "\(.*\)"/\1/')
          
          if [ "$GITOPS_DIGEST" == "$TARGET_DIGEST" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "✅ GitOps digest unchanged: gitops: $GITOPS_DIGEST vs $TARGET_DIGEST"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "🔄 GitOps digest will change: digest to be replace: $GITOPS_DIGEST → digest to be replaced by: $TARGET_DIGEST"
          fi

      - name: Update GitOps repository
        if: ${{ steps.check-gitops-changes.outputs.changed == 'true' }}
        id: create-pr
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
          ENVIRONMENT: ${{ github.event.inputs.env }}
          TARGET_DIGEST: ${{ steps.final-digest.outputs.digest_only }}
        run: |
          cd gitops-repo
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          BRANCH_NAME="frontend-update-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          git checkout -b "$BRANCH_NAME"
          
          sed -i "s|digest: \"sha256:.*\"|digest: \"${TARGET_DIGEST}\"|g" environments/${ENVIRONMENT}/manifests/frontend/digest-values.yaml
          git add environments/${ENVIRONMENT}/manifests/frontend/digest-values.yaml
          git commit -m "Update frontend digest for ${ENVIRONMENT}: ${TARGET_DIGEST}"
          git push origin "$BRANCH_NAME"
          
          # Create PR and capture response
          PR_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${GITOPS_REPO}/pulls" \
            -d "{\"title\":\"Frontend: Update ${ENVIRONMENT} digest\",\"head\":\"${BRANCH_NAME}\",\"base\":\"main\",\"body\":\"Automated digest update for ${ENVIRONMENT} environment\"}")
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          if [ "$PR_NUMBER" != "null" ] && [ -n "$PR_NUMBER" ]; then
            echo "✅ Created PR #${PR_NUMBER}"
          else
            echo "❌ Failed to create PR. Response: $PR_RESPONSE"
            exit 1
          fi
      
      - name: Auto-merge GitOps PR
        if: ${{ steps.check-gitops-changes.outputs.changed == 'true' && github.event.inputs.auto_merge == 'true' }}
        env:
          GH_TOKEN: "${{ env.GH_TOKEN }}"
          GITOPS_REPO: ${{ env.GITOPS_REPO }}
        run: |
          PR_NUMBER="${{ steps.create-pr.outputs.pr_number }}"
          
          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
            echo "🔀 Triggering auto-merge for PR #${PR_NUMBER}..."
            
            curl -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${GITOPS_REPO}/dispatches" \
              -d "{\"event_type\":\"auto-merge-pr\",\"client_payload\":{\"pr_number\":${PR_NUMBER}}}"
            
            echo "✅ Auto-merge workflow triggered for PR #${PR_NUMBER}"
          else
            echo "❌ No PR found to auto-merge"
          fi
      
      - name: Build Summary
        run: |
          echo "## 🚀 Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.env }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy:** ${{ steps.build-strategy.outputs.strategy }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Action:** ${{ github.event.inputs.action }}" >> $GITHUB_STEP_SUMMARY
          
          # ECR Digest Prior to the changes
          # no condition, if there are no digest the job fails anyway
          echo "- **ECR Digest Prior to the changes:** ${{ steps.ecr-check.outputs.existing_digest }}" >> $GITHUB_STEP_SUMMARY
          
          # If there were changes (meaning push = true)-> print the new digest which is the final digest
          if [ "${{ steps.push-decision.outputs.should_push }}" == "true" ]; then
            echo "- **ECR Digest after the changes:** ${{ steps.final-digest.outputs.digest_only }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- **Content Tag:** ${{ steps.content-hash.outputs.content_tag }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.build-strategy.outputs.should_build }}" == "true" ]; then
            echo "- **Built Image:** ${{ steps.meta.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
            #echo "- **Local content-hash:** ${{ steps.content-hash.outputs.content_hash }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Pushed to ECR:** ${{ steps.push-decision.outputs.should_push }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "- **GitOps Changed:** ${{ steps.check-gitops-changes.outputs.changed }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check-gitops-changes.outputs.changed }}" == "true" ]; then
            echo "- **PR Created:** #${{ steps.create-pr.outputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Auto-merge:** ${{ github.event.inputs.auto_merge }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Result:** No changes needed - everything up to date ✅" >> $GITHUB_STEP_SUMMARY
          fi
